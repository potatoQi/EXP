"""Utilities for managing project-level environment variables stored in a `.env` file."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Optional

import os
import re
from urllib.parse import parse_qs, urlparse

PROJECT_MARKERS = {"pyproject.toml", ".git"}
ENV_FILE_NAME = ".env"

_ENV_LOADED = False

LARK_ENV_MAPPING = {
    "app_id": "LARK_APP_ID",
    "app_secret": "LARK_APP_SECRET",
    "app_token": "LARK_APP_TOKEN",
    "table_id": "LARK_TABLE_ID",
    "view_id": "LARK_VIEW_ID",
}


@dataclass(frozen=True)
class EnvFile:
    """Container describing the resolved project root and env path."""

    project_root: Path
    env_path: Path


def find_project_root(start: Optional[Path] = None) -> Path:
    """Best-effort discovery of the project root directory.

    The search walks up from *start* (or ``Path.cwd()``) until it encounters a
    directory containing one of the ``PROJECT_MARKERS``. If no marker is found,
    the initial absolute directory is returned.
    """

    start_path = (start or Path.cwd()).resolve()
    current = start_path
    while True:
        for marker in PROJECT_MARKERS:
            if (current / marker).exists():
                return current
        parent = current.parent
        if parent == current:
            # Reached filesystem root
            return start_path
        current = parent


def resolve_env_file(start: Optional[Path] = None) -> EnvFile:
    """Locate the project root and associated ``.env`` file path."""

    project_root = find_project_root(start)
    env_path = project_root / ENV_FILE_NAME
    return EnvFile(project_root=project_root, env_path=env_path)


def _parse_env_line(line: str) -> Optional[tuple[str, str]]:
    stripped = line.strip()
    if not stripped or stripped.startswith("#"):
        return None
    if "=" not in stripped:
        return None
    key, value = stripped.split("=", 1)
    key = key.strip()
    value = value.strip()
    if value.startswith(("'", '"')) and value.endswith(("'", '"')) and len(value) >= 2:
        # Remove surrounding quotes and unescape
        quote = value[0]
        value = value[1:-1]
        if quote == '"':
            value = value.replace('\\"', '"').replace('\\\\', '\\')
        else:
            value = value.replace("\\'", "'").replace('\\\\', '\\')
    return key, value


def read_env(env_path: Path) -> Dict[str, str]:
    """Read key/value pairs from ``env_path`` if it exists."""

    if not env_path.exists():
        return {}
    data: Dict[str, str] = {}
    try:
        with open(env_path, "r", encoding="utf-8") as fh:
            for line in fh:
                parsed = _parse_env_line(line)
                if not parsed:
                    continue
                key, value = parsed
                data[key] = value
    except OSError:
        return {}
    return data


def _needs_quoting(value: str) -> bool:
    return not value or any(ch.isspace() for ch in value) or any(
        ch in value for ch in "#'\""
    )


def _format_env_value(value: str) -> str:
    if not value:
        return ""
    if _needs_quoting(value):
        escaped = value.replace("\\", "\\\\").replace('"', '\\"')
        return f'"{escaped}"'
    return value


def write_env(env_path: Path, data: Dict[str, str]) -> None:
    """Persist *data* to ``env_path``.

    The file is rewritten entirely with alphabetical ordering to provide
    deterministic output. Keys mapped to ``None`` are removed from the result.
    """

    env_path.parent.mkdir(parents=True, exist_ok=True)
    sorted_items = sorted((key, value) for key, value in data.items() if value is not None)
    lines = ["# Generated by EMP set_env" + os.linesep]
    for key, value in sorted_items:
        lines.append(f"{key}={_format_env_value(value)}{os.linesep}")
    with open(env_path, "w", encoding="utf-8") as fh:
        fh.writelines(lines)


def load_project_env(apply: bool = True, start: Optional[Path] = None) -> Dict[str, str]:
    """加载项目的 .env 文件，并根据 apply 选择性地填充 os.environ"""
    env_file = resolve_env_file(start)  # 从 start 开始搜, 找到项目根目录和 .env 文件路径
    data = read_env(env_file.env_path)
    if apply:
        for key, value in data.items():
            os.environ.setdefault(key, value)
    return data


def update_project_env(updates: Dict[str, Optional[str]], start: Optional[Path] = None) -> EnvFile:
    """Merge *updates* into the project ``.env`` file.

    ``updates`` maps keys to their desired value. ``None`` removes the key.
    Returns the :class:`EnvFile` describing the resolved location.
    """

    env_file = resolve_env_file(start)
    current = read_env(env_file.env_path)
    for key, value in updates.items():
        if value is None:
            current.pop(key, None)
        else:
            current[key] = value
    write_env(env_file.env_path, current)
    return env_file


def iter_missing_keys(required: Iterable[str], env_map: Dict[str, str]) -> Iterable[str]:
    for key in required:
        if not env_map.get(key):
            yield key


def get_lark_env_config(source: Optional[Dict[str, str]] = None) -> Dict[str, str]:
    env = source or os.environ
    config: Dict[str, str] = {}
    for field, env_key in LARK_ENV_MAPPING.items():
        value = env.get(env_key)
        if value:
            config[field] = value
    return config


def ensure_project_env_loaded(start: Optional[Path] = None) -> None:
    global _ENV_LOADED
    # _ENV_LOADED 表示是否已经加载过 .env 文件
    if _ENV_LOADED:
        return
    # apply 表示将读取到的环境变量应用到 os.environ 中, start 表示从哪里开始去搜 .env 所在路径
    load_project_env(apply=True, start=start)
    _ENV_LOADED = True


_APP_TOKEN_RE = re.compile(r"app[0-9A-Za-z]{5,}")
_TABLE_TOKEN_RE = re.compile(r"tbl[0-9A-Za-z]{5,}")
_VIEW_TOKEN_RE = re.compile(r"vew[0-9A-Za-z]{5,}")
_URL_QUERY_KEYS = {
    "table_id": ("table", "tableId", "table_id"),
    "view_id": ("view", "viewId", "view_id"),
}


def parse_bitable_url(url: str) -> Dict[str, str]:
    """Extract ``app_token``/``table_id``/``view_id`` from a Feishu Bitable URL.

    The parser works best with URLs in the ``feishu.cn/base`` format. For
    knowledge-base (``feishu.cn/wiki``) URLs, Feishu only exposes the
    ``app_token`` via the 知识库节点 API, so the parser will likely return an
    empty ``app_token`` unless the token already appears in the URL.
    """

    if not url:
        return {}

    parsed = urlparse(url)
    tokens: Dict[str, str] = {}

    # Extract app_token from the path, e.g. /base/appbxxx/... or /bitable/appbxxx
    path_segments = [segment for segment in parsed.path.split("/") if segment]
    for segment in path_segments:
        if _APP_TOKEN_RE.fullmatch(segment):
            tokens["app_token"] = segment
            break

    # Some newer share URLs expose the token directly after "/base/" but without
    # the traditional "app"/"bas" prefix. In such cases we heuristically take
    # the segment following "base"/"bitable".
    if "app_token" not in tokens:
        for idx, segment in enumerate(path_segments[:-1]):
            if segment.lower() in {"base", "bitable"}:
                candidate = path_segments[idx + 1]
                if candidate:
                    tokens["app_token"] = candidate
                break

    def _consume_query(query: str) -> None:
        if not query:
            return
        qs = parse_qs(query, keep_blank_values=True)
        for key, aliases in _URL_QUERY_KEYS.items():
            for alias in aliases:
                values = qs.get(alias)
                if values:
                    value = values[0]
                    if value:
                        tokens.setdefault(key, value)
                        break

    _consume_query(parsed.query)

    # Some share links place query params inside the fragment portion.
    if "=" in parsed.fragment:
        _consume_query(parsed.fragment)

    # As a fallback, detect tokens appearing directly in the path or fragment.
    if "app_token" not in tokens:
        for segment in path_segments:
            match = _APP_TOKEN_RE.search(segment)
            if match:
                tokens["app_token"] = match.group(0)
                break
        else:
            match = _APP_TOKEN_RE.search(parsed.fragment)
            if match:
                tokens["app_token"] = match.group(0)

    for token_key, pattern in (("table_id", _TABLE_TOKEN_RE), ("view_id", _VIEW_TOKEN_RE)):
        if token_key in tokens:
            continue
        for segment in path_segments:
            match = pattern.search(segment)
            if match:
                tokens[token_key] = match.group(0)
                break
        else:
            match = pattern.search(parsed.fragment)
            if match:
                tokens[token_key] = match.group(0)

    return tokens

__all__ = [
    "EnvFile",
    "load_project_env",
    "update_project_env",
    "resolve_env_file",
    "find_project_root",
    "iter_missing_keys",
    "get_lark_env_config",
    "ensure_project_env_loaded",
    "parse_bitable_url",
]
